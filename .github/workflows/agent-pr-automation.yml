name: Agent PR Automation

on:
  pull_request_target:
    types: [opened, reopened, synchronize, labeled, ready_for_review]
    branches: [main]

# Serialize all rebase+merge operations to prevent race conditions
concurrency:
  group: agent-merge-queue
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-rebase:
    if: contains(github.event.pull_request.labels.*.name, 'agent-task')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0
          token: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}

      - name: Rebase onto main (clean only)
        id: rebase
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin main

          # Check if rebase is needed
          BEHIND=$(git rev-list --count HEAD..origin/main)
          if [ "$BEHIND" = "0" ]; then
            echo "Already up to date with main"
            echo "status=uptodate" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Only attempt clean rebase — never silently overwrite agent work
          if git rebase origin/main; then
            echo "Clean rebase succeeded"
            git push --force-with-lease origin ${{ github.event.pull_request.head.ref }}
            echo "status=rebased" >> $GITHUB_OUTPUT
          else
            echo "::warning::Rebase has conflicts — skipping (unstick workflow will handle)"
            git rebase --abort
            echo "status=conflicts" >> $GITHUB_OUTPUT
          fi

      - name: Label conflicts for unstick workflow
        if: steps.rebase.outputs.status == 'conflicts'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const labels = pr.labels.map(l => l.name);
            if (!labels.includes('needs-rebase')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['needs-rebase'],
              });
              core.info(`Added needs-rebase label to PR #${pr.number}`);
            }

  auto-merge:
    if: |
      github.event.pull_request.draft == false &&
      contains(github.event.pull_request.labels.*.name, 'agent-task') &&
      contains(github.event.pull_request.labels.*.name, 'agent-work-done') &&
      contains(github.event.pull_request.labels.*.name, 'agent-automerge') &&
      (
        (github.event.action == 'labeled' && github.event.label.name == 'agent-work-done') ||
        github.event.action == 'synchronize'
      )
    runs-on: ubuntu-latest
    needs: auto-rebase
    # Only merge if rebase succeeded (not conflicts)
    # unstick-draft-prs.yml handles conflict escalation
    steps:
      - name: Merge PR directly
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            core.info(`Evaluating PR #${pr.number} (${pr.title}) for auto-merge...`);

            const { data: latest } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pr.number,
            });

            const labelNames = latest.labels.map(l => l.name);
            if (latest.draft) {
              core.info(`PR #${pr.number} is still draft; skipping merge.`);
              return;
            }
            if (!labelNames.includes('agent-work-done')) {
              core.info(`PR #${pr.number} missing agent-work-done label; skipping merge.`);
              return;
            }
            if (latest.mergeable === false) {
              core.info(`PR #${pr.number} has merge conflicts; skipping merge.`);
              return;
            }
            if (latest.mergeable === null) {
              core.info(`PR #${pr.number} mergeability is still pending; skipping for now.`);
              return;
            }
            
            try {
              const result = await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: pr.number,
                merge_method: 'squash',
                commit_title: pr.title,
                commit_message: `${latest.body || ''}\n\nAuto-merged by agent automation workflow.`
              });
              
              core.info(`✅ PR #${pr.number} merged successfully`);
              core.info(`Merge SHA: ${result.data.sha}`);
              core.info(`Merged: ${result.data.merged}`);
            } catch (error) {
              core.error(`Failed to merge PR: ${error.message}`);
              
              // Add comment explaining the failure
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body: `⚠️ **Automatic merge failed**: ${error.message}\n\nPlease merge manually.`
              });
              
              throw error;
            }
