name: Unstick Agent Draft PRs

# Processes agent draft PRs: detect done â†’ rebase/resolve conflicts â†’ mark ready â†’ merge.
# Triggers:
#   - Cron every 5 min (GitHub may skip; self-dispatch compensates)
#   - On push to main (catches post-merge immediately)
#   - Manual dispatch
on:
  schedule:
    - cron: '*/5 * * * *'
  push:
    branches: [main]
  workflow_dispatch:

# Serialize merge operations to prevent cascading stale-branch conflicts
concurrency:
  group: agent-merge-queue
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  unstick:
    runs-on: ubuntu-latest
    env:
      PAT_COLLAB_TWO: ${{ secrets.PAT_COLLAB_TWO }}
      AGENT_PAT: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT }}
      AGENT_PAT_COLLAB: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB }}
    steps:
      - name: Checkout repo (needed for rebase operations)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}

      - name: Process all agent draft PRs
        id: process
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Track whether we need to re-run (pending PRs that couldn't be processed)
            let needsRetry = false;
            // Track whether a slot freed up and we should assign next issue
            let needsAssignment = false;
            // Track whether roadmap scanner should run (after merge completes a feature)
            let needsRoadmapScan = false;

            // Copilot-only: all known Copilot agent bot logins
            const AGENT_BOTS = new Set([
              'Copilot',
              'copilot-swe-agent[bot]',
              'app/copilot-swe-agent',
            ]);

            // Agent for reassignment (Copilot only)
            const AGENT_REASSIGN = [
              { botUser: 'copilot-swe-agent[bot]', name: 'Copilot' },
            ];

            // Timing thresholds
            const MIN_AGE_MINUTES = 30;
            const MIN_STALE_MINUTES = 15;
            const MIN_RUNTIME_STALL_MINUTES = 15;

            // Map PR author to their expected runtime workflow name
            const RUNTIME_WORKFLOWS = {
              'Copilot': 'Running Copilot coding agent',
              'copilot-swe-agent[bot]': 'Running Copilot coding agent',
              'app/copilot-swe-agent': 'Running Copilot coding agent',
            };

            // Check if an agent's runtime workflow has completed or is still active
            async function getAgentRuntimeState(prAuthor, prNumber, headSha) {
              const workflowName = RUNTIME_WORKFLOWS[prAuthor];
              if (!workflowName) {
                return { done: false, active: false, seen: false };
              }
              try {
                const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  head_sha: headSha,
                  per_page: 10,
                });
                const { data: recentRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  per_page: 50,
                });
                const allRuns = [...runs.workflow_runs, ...recentRuns.workflow_runs];
                const runtimeRuns = allRuns.filter((run) => {
                  if (run.name !== workflowName) return false;
                  if (run.head_sha === headSha) return true;
                  if (Array.isArray(run.pull_requests)) {
                    return run.pull_requests.some((linkedPr) => linkedPr.number === prNumber);
                  }
                  return false;
                });
                return {
                  done: runtimeRuns.some((run) => run.status === 'completed'),
                  active: runtimeRuns.some((run) => run.status !== 'completed'),
                  seen: runtimeRuns.length > 0
                };
              } catch {
                return { done: false, active: false, seen: false };
              }
            }

            // Try to rebase a branch onto main using git (clean rebase only)
            function tryRebase(branchName) {
              try {
                execSync('git config user.name "github-actions[bot]"', { stdio: 'pipe' });
                execSync('git config user.email "github-actions[bot]@users.noreply.github.com"', { stdio: 'pipe' });
                execSync('git fetch origin main', { stdio: 'pipe' });
                execSync(`git fetch origin ${branchName}`, { stdio: 'pipe' });
                execSync(`git checkout ${branchName}`, { stdio: 'pipe' });
                execSync('git reset --hard', { stdio: 'pipe' });

                // Check if rebase is needed
                const behindCount = execSync('git rev-list --count HEAD..origin/main', { encoding: 'utf8' }).trim();
                if (behindCount === '0') {
                  return { success: true, needed: false };
                }

                // Attempt clean rebase only â€” never silently overwrite agent work
                try {
                  execSync('git rebase origin/main', { stdio: 'pipe' });
                  execSync(`git push --force-with-lease origin ${branchName}`, { stdio: 'pipe' });
                  return { success: true, needed: true };
                } catch {
                  // Clean rebase failed â€” conflicts exist, don't try to auto-resolve
                  // Agent work should not be silently overwritten with main's version
                  try { execSync('git rebase --abort', { stdio: 'pipe' }); } catch {}
                  return { success: false, needed: true };
                }
              } catch (err) {
                try { execSync('git rebase --abort', { stdio: 'pipe' }); } catch {}
                return { success: false, needed: true, error: err.message };
              }
            }

            // Extract linked issue number from PR body
            // Handles: "Fixes #74", "Fixes owner/repo#74", "Closes https://github.com/owner/repo/issues/74"
            function extractLinkedIssue(body) {
              if (!body) return null;
              // Try "Fixes owner/repo#N" or "Fixes #N"
              const hashMatch = body.match(/(?:Fixes|Closes|Resolves)\s+(?:[\w.-]+\/[\w.-]+)?#(\d+)/i);
              if (hashMatch) return parseInt(hashMatch[1]);
              // Try full URL: github.com/owner/repo/issues/N
              const urlMatch = body.match(/(?:Fixes|Closes|Resolves)\s+https:\/\/github\.com\/[\w.-]+\/[\w.-]+\/issues\/(\d+)/i);
              if (urlMatch) return parseInt(urlMatch[1]);
              return null;
            }

            // Assign an agent to fix merge conflicts on a PR
            async function assignAgentToFixConflicts(pr, issueNumber) {
              const token = process.env.PAT_COLLAB_TWO || process.env.AGENT_PAT_COLLAB || process.env.AGENT_PAT || process.env.GITHUB_TOKEN;

              await github.rest.issues.createComment({
                owner, repo,
                issue_number: pr.number,
                body: [
                  'âš ï¸ **Merge conflicts detected** that could not be automatically resolved.',
                  '',
                  'Closing this PR and reassigning the linked issue to an agent for a fresh attempt.',
                ].join('\n'),
              });

              if (issueNumber) {
                core.info(`  Closing conflicting PR and reassigning issue #${issueNumber}`);

                await github.rest.pulls.update({
                  owner, repo,
                  pull_number: pr.number,
                  state: 'closed',
                });

                // Remove existing assignees
                try {
                  const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                  const currentAssignees = issue.assignees.map(a => a.login);
                  if (currentAssignees.length > 0) {
                    await github.rest.issues.removeAssignees({
                      owner, repo,
                      issue_number: issueNumber,
                      assignees: currentAssignees,
                    });
                  }
                } catch (err) {
                  core.warning(`  Could not remove assignees: ${err.message}`);
                }

                await new Promise(r => setTimeout(r, 2000));

                // Try each agent in priority order
                let reassigned = false;
                for (const provider of AGENT_REASSIGN) {
                  try {
                    const body = { assignees: [provider.botUser] };
                    body.agent_assignment = {
                      target_repo: `${owner}/${repo}`,
                      base_branch: 'main',
                      model: 'claude-sonnet-4.5',
                    };
                    const response = await fetch(
                      `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`,
                      {
                        method: 'POST',
                        headers: {
                          'Authorization': `token ${token}`,
                          'Accept': 'application/vnd.github+json',
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(body),
                      }
                    );
                    if (response.ok) {
                      const data = await response.json();
                      const logins = (data.assignees || []).map(a => a.login);
                      if (logins.includes(provider.name) || logins.includes(provider.botUser)) {
                        core.info(`  Reassigned issue #${issueNumber} to ${provider.name}`);
                        reassigned = true;
                        await github.rest.issues.createComment({
                          owner, repo,
                          issue_number: issueNumber,
                          body: `PR #${pr.number} closed due to unresolvable conflicts. Reassigned to **${provider.name}** for a fresh attempt.`,
                        });
                        break;
                      }
                    }
                  } catch (err) {
                    core.warning(`  ${provider.name} reassignment failed: ${err.message}`);
                  }
                }
                if (!reassigned) {
                  core.warning(`  Could not reassign issue #${issueNumber} â€” reopening PR`);
                  await github.rest.pulls.update({
                    owner, repo,
                    pull_number: pr.number,
                    state: 'open',
                  });
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: pr.number,
                    labels: ['needs-conflict-resolution'],
                  });
                }
              } else {
                // No linked issue in PR body â€” try to find matching issue by title similarity
                core.info(`  No linked issue in PR body â€” searching for matching open issue...`);

                // Close the PR first
                await github.rest.pulls.update({
                  owner, repo,
                  pull_number: pr.number,
                  state: 'closed',
                });
                core.info(`  Closed conflicting PR #${pr.number}`);

                // Search open issues with agent-task label for a title match
                try {
                  const { data: openIssues } = await github.rest.issues.listForRepo({
                    owner, repo,
                    state: 'open',
                    labels: 'agent-task',
                    per_page: 30,
                  });
                  // Find best match: issue title words overlap with PR title
                  const prWords = new Set(pr.title.toLowerCase().replace(/\[wip\]/gi, '').split(/\W+/).filter(w => w.length > 3));
                  let bestMatch = null;
                  let bestScore = 0;
                  for (const issue of openIssues) {
                    const issueWords = new Set(issue.title.toLowerCase().split(/\W+/).filter(w => w.length > 3));
                    const overlap = [...prWords].filter(w => issueWords.has(w)).length;
                    const score = overlap / Math.max(prWords.size, 1);
                    if (score > bestScore && score >= 0.3) {
                      bestScore = score;
                      bestMatch = issue;
                    }
                  }
                  if (bestMatch) {
                    core.info(`  Found matching issue #${bestMatch.number}: ${bestMatch.title} (score: ${bestScore.toFixed(2)})`);
                    // Remove existing assignees and let orchestrator reassign
                    const currentAssignees = bestMatch.assignees.map(a => a.login);
                    if (currentAssignees.length > 0) {
                      await github.rest.issues.removeAssignees({
                        owner, repo,
                        issue_number: bestMatch.number,
                        assignees: currentAssignees,
                      });
                    }
                    await github.rest.issues.createComment({
                      owner, repo,
                      issue_number: bestMatch.number,
                      body: `PR #${pr.number} closed due to unresolvable merge conflicts. Unassigned for fresh agent pickup.`,
                    });
                    core.info(`  Unassigned issue #${bestMatch.number} for reassignment`);
                    needsAssignment = true;
                  } else {
                    core.warning(`  No matching issue found â€” PR closed, needs manual review`);
                  }
                } catch (err) {
                  core.warning(`  Issue search failed: ${err.message}`);
                }
              }
            }

            // Assign Copilot coding agent to an issue via REST API
            async function assignCopilotToIssue(issueNumber) {
              const token = process.env.PAT_COLLAB_TWO || process.env.AGENT_PAT_COLLAB || process.env.AGENT_PAT;
              if (!token) {
                core.warning('No PAT available for Copilot assignment');
                return false;
              }
              try {
                const response = await fetch(
                  `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`,
                  {
                    method: 'POST',
                    headers: {
                      'Authorization': `token ${token}`,
                      'Accept': 'application/vnd.github+json',
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                      assignees: ['copilot-swe-agent[bot]'],
                      agent_assignment: {
                        target_repo: `${owner}/${repo}`,
                        base_branch: 'main',
                        model: 'claude-sonnet-4.5',
                      },
                    }),
                  }
                );
                if (response.ok) {
                  core.info(`  âœ… Assigned Copilot to issue #${issueNumber}`);
                  return true;
                }
                core.warning(`  Copilot assignment returned ${response.status}`);
                return false;
              } catch (err) {
                core.warning(`  Copilot assignment failed: ${err.message}`);
                return false;
              }
            }

            // Check if Copilot recently hit rate limits (avoid reassigning into a storm)
            async function isRateLimited() {
              try {
                const { data: closedPRs } = await github.rest.pulls.list({
                  owner, repo,
                  state: 'closed',
                  sort: 'updated',
                  direction: 'desc',
                  per_page: 10,
                });
                const since = Date.now() - 60 * 60 * 1000;
                const recent = closedPRs.filter(pr => pr.closed_at && new Date(pr.closed_at).getTime() > since);
                for (const closedPR of recent) {
                  try {
                    const { data: comments } = await github.rest.issues.listComments({
                      owner, repo,
                      issue_number: closedPR.number,
                      per_page: 5,
                      sort: 'created',
                      direction: 'desc',
                    });
                    if (comments.some(c => c.body && (c.body.includes('rate limit') || c.body.includes('rate_limit')))) {
                      core.info(`  âš ï¸ Rate limit detected on recently closed PR #${closedPR.number}`);
                      return true;
                    }
                  } catch {}
                }
                return false;
              } catch {
                return false;
              }
            }

            // Find and assign the next unassigned agent-task issue
            async function assignNextUnassignedIssue() {
              // Check rate limits (skip on manual dispatch)
              if (context.eventName !== 'workflow_dispatch') {
                if (await isRateLimited()) {
                  core.info('  â¸ Backing off â€” Copilot hit rate limits recently');
                  return false;
                }
              }

              // Check if agent slot is available
              const { data: openPRs } = await github.rest.pulls.list({
                owner, repo,
                state: 'open',
                per_page: 50,
              });
              const agentPRCount = openPRs.filter(p => AGENT_BOTS.has(p.user.login)).length;
              if (agentPRCount >= 1) {
                core.info(`  â¸ Agent slot full (${agentPRCount} active PR(s))`);
                return false;
              }

              // Find unassigned agent-task issues
              const { data: issues } = await github.rest.issues.listForRepo({
                owner, repo,
                state: 'open',
                labels: 'agent-task',
                per_page: 50,
              });
              const unassigned = issues.filter(i => !i.pull_request && (!i.assignees || i.assignees.length === 0));
              if (unassigned.length === 0) {
                core.info('  No unassigned agent-task issues found');
                return false;
              }

              const next = unassigned[0];
              core.info(`  Next issue: #${next.number} â€” ${next.title}`);
              return await assignCopilotToIssue(next.number);
            }

            // â”€â”€â”€ Main logic â”€â”€â”€

            const { data: prs } = await github.rest.pulls.list({
              owner, repo,
              state: 'open',
              per_page: 100,
            });

            const agentPRs = prs.filter(pr => AGENT_BOTS.has(pr.user.login));
            core.info(`Found ${agentPRs.length} open agent PRs`);

            for (const pr of agentPRs) {
              core.info(`\n--- PR #${pr.number}: ${pr.title} (by ${pr.user.login}, draft: ${pr.draft}) ---`);

              const now = Date.now();
              const createdAt = new Date(pr.created_at).getTime();
              const updatedAt = new Date(pr.updated_at).getTime();
              const ageMinutes = Math.round((now - createdAt) / 60000);
              const staleMins = Math.round((now - updatedAt) / 60000);
              core.info(`  Age: ${ageMinutes}m, last updated: ${staleMins}m ago`);

              // Check runtime state
              const runtime = await getAgentRuntimeState(pr.user.login, pr.number, pr.head.sha);
              core.info(`  Runtime: done=${runtime.done}, active=${runtime.active}, seen=${runtime.seen}`);

              // Skip very recently updated drafts while agent is likely still working
              if (pr.draft && staleMins < MIN_STALE_MINUTES && !runtime.done) {
                core.info(`  Skipping: updated ${staleMins}m ago and runtime not done`);
                needsRetry = true;
                continue;
              }

              // Check file changes
              const { data: files } = await github.rest.pulls.listFiles({
                owner, repo,
                pull_number: pr.number,
              });

              if (files.length === 0) {
                // Check if runtime is stalled (same logic used later, computed early here)
                const earlyRuntimeStalled =
                  (!runtime.done && !runtime.active && staleMins >= MIN_RUNTIME_STALL_MINUTES);

                if (runtime.done || earlyRuntimeStalled) {
                  // Check if agent intentionally finished with 0 changes
                  // (e.g., verified feature already exists). If the agent marked the PR
                  // as ready for review (not draft) and runtime completed normally,
                  // it considers the work done â€” close the issue as completed, not for retry.
                  const agentConsideredDone = !pr.draft && runtime.done && !earlyRuntimeStalled;

                  if (agentConsideredDone) {
                    core.info(`  Agent marked PR ready with 0 file changes â€” work already done`);
                    await github.rest.issues.createComment({
                      owner, repo,
                      issue_number: pr.number,
                      body: [
                        'âœ… **Agent verified: no code changes needed.**',
                        '',
                        'The agent completed its session and marked this PR ready for review with 0 file changes.',
                        'This typically means the feature was already implemented. Closing PR and issue as completed.',
                      ].join('\n'),
                    });
                  } else {
                    core.warning(`  Agent produced 0 files (runtime done=${runtime.done}, stalled=${earlyRuntimeStalled}) â€” closing PR`);
                    await github.rest.issues.createComment({
                      owner, repo,
                      issue_number: pr.number,
                      body: [
                        'ðŸ›‘ **Agent session ended with no code changes.**',
                        '',
                        'The agent runtime finished but produced 0 file changes (likely crashed or hit rate limits).',
                        'Closing this PR and freeing the linked issue for a fresh agent attempt.',
                      ].join('\n'),
                    });
                  }

                  await github.rest.pulls.update({
                    owner, repo,
                    pull_number: pr.number,
                    state: 'closed',
                  });
                  core.info(`  Closed empty PR #${pr.number}`);

                  // Find linked issue
                  const issueNumber = extractLinkedIssue(pr.body);
                  if (issueNumber) {
                    if (agentConsideredDone) {
                      // Agent said work is done â€” close issue as completed
                      try {
                        await github.rest.issues.update({
                          owner, repo,
                          issue_number: issueNumber,
                          state: 'closed',
                          state_reason: 'completed',
                        });
                        core.info(`  âœ“ Closed linked issue #${issueNumber} as completed (no changes needed)`);
                      } catch (err) {
                        core.warning(`  Could not close issue #${issueNumber}: ${err.message}`);
                      }
                      needsAssignment = true;
                      needsRoadmapScan = true;
                    } else {
                      // Agent failed â€” free issue for retry
                      try {
                        const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                        const currentAssignees = issue.assignees.map(a => a.login);
                        if (currentAssignees.length > 0) {
                          await github.rest.issues.removeAssignees({
                            owner, repo,
                            issue_number: issueNumber,
                            assignees: currentAssignees,
                          });
                        }
                      } catch (err) {
                        core.warning(`  Could not remove assignees from issue #${issueNumber}: ${err.message}`);
                      }

                      await github.rest.issues.createComment({
                        owner, repo,
                        issue_number: issueNumber,
                        body: `PR #${pr.number} closed â€” agent produced no code changes. Issue is now unassigned and ready for a fresh agent dispatch.`,
                      });
                      core.info(`  Cleared assignees on issue #${issueNumber}`);
                      needsAssignment = true;
                    }
                  }

                  continue;
                }

                // Agent still running but hasn't pushed code yet â€” retry later
                core.info(`  Skipping: 0 files changed, agent still running â€” will retry`);
                needsRetry = true;
                continue;
              }
              core.info(`  ${files.length} file(s) changed`);

              let labels = pr.labels.map(l => l.name);

              // Clear stale agent-work-done if agent pushed new work on a draft
              if (pr.draft && !runtime.done && labels.includes('agent-work-done')) {
                try {
                  await github.rest.issues.removeLabel({
                    owner, repo,
                    issue_number: pr.number,
                    name: 'agent-work-done',
                  });
                  labels = labels.filter(n => n !== 'agent-work-done');
                  core.info(`  Removed stale agent-work-done label`);
                } catch (err) {
                  core.warning(`  Could not remove stale label: ${err.message}`);
                }
              }

              // If PR already has agent-work-done label (from a previous run) and is not draft,
              // treat it as effectively done â€” the runtime check is no longer relevant
              // (e.g., head SHA changed after rebase so runtime runs can't be found).
              const alreadyMarkedDone = !pr.draft && labels.includes('agent-work-done');

              // Determine if runtime is stalled
              const runtimeStalled =
                labels.includes('agent-runtime-timeout') ||
                (!runtime.done && !runtime.active && staleMins >= MIN_RUNTIME_STALL_MINUTES);

              // Only proceed if runtime is done, stalled, or already marked done
              if (!runtime.done && !runtimeStalled && !alreadyMarkedDone) {
                core.info(`  Runtime not done, not stalled â€” skipping`);
                needsRetry = true;
                continue;
              }

              if (runtimeStalled) {
                core.warning(`  Runtime stalled for ${staleMins}m â€” force progressing`);
              }

              // â”€â”€â”€ STEP 1: Rebase onto main BEFORE marking ready â”€â”€â”€
              core.info(`  Attempting rebase onto main...`);
              const rebaseResult = tryRebase(pr.head.ref);

              if (rebaseResult.needed && rebaseResult.success) {
                core.info(`  âœ“ Rebase successful`);
                // Remove needs-rebase label if it was set by agent-pr-automation
                try {
                  await github.rest.issues.removeLabel({
                    owner, repo,
                    issue_number: pr.number,
                    name: 'needs-rebase',
                  });
                } catch {} // Label may not exist â€” ignore
                // Wait for GitHub to process the push
                await new Promise(r => setTimeout(r, 3000));
              } else if (rebaseResult.needed && !rebaseResult.success) {
                core.warning(`  âœ— Rebase failed â€” unresolvable merge conflicts`);

                // If agent runtime is done (or no runtime found), no point waiting â€” escalate immediately.
                // Only wait for young PRs when agent is actively running.
                const agentDone = runtime.done || !runtime.seen || runtimeStalled;
                if (!agentDone && ageMinutes < MIN_AGE_MINUTES) {
                  core.info(`  PR only ${ageMinutes}m old and agent may still be working â€” will retry next run`);
                  continue;
                }

                // Assign an agent to fix the conflicts
                const issueNumber = extractLinkedIssue(pr.body);
                await assignAgentToFixConflicts(pr, issueNumber);
                continue;
              } else {
                core.info(`  Already up to date with main`);
              }

              // â”€â”€â”€ STEP 2: Verify mergeability after rebase â”€â”€â”€
              const { data: prDetail } = await github.rest.pulls.get({
                owner, repo,
                pull_number: pr.number,
              });

              if (prDetail.mergeable === false) {
                core.warning(`  Still has conflicts after rebase â€” will retry next run`);
                continue;
              }

              // â”€â”€â”€ STEP 3: Mark ready for review (only if no conflicts) â”€â”€â”€
              if (pr.draft && prDetail.mergeable !== false) {
                try {
                  const mutation = `mutation($id: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $id }) {
                      pullRequest { id number isDraft }
                    }
                  }`;
                  await github.graphql(mutation, { id: pr.node_id });
                  pr.draft = false; // Update local state so Steps 6/7 see the PR as ready
                  core.info(`  âœ“ Marked PR #${pr.number} as ready for review`);
                } catch (err) {
                  core.warning(`  Could not mark ready: ${err.message}`);
                  continue;
                }
              }

              // â”€â”€â”€ STEP 4: Re-run action_required workflow runs â”€â”€â”€
              // GitHub blocks pull_request_target workflows for bot accounts
              // with "action_required". We can't approve them (403 for non-fork PRs),
              // but re-running them works.
              try {
                const { data: allRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  head_sha: prDetail.head.sha,
                  per_page: 30,
                });
                const stuckRuns = allRuns.workflow_runs.filter(r => r.conclusion === 'action_required');
                for (const run of stuckRuns) {
                  try {
                    await github.rest.actions.reRunWorkflow({ owner, repo, run_id: run.id });
                    core.info(`  Re-ran stuck workflow run ${run.id} (${run.name})`);
                  } catch (err) {
                    core.warning(`  Could not re-run ${run.id}: ${err.message}`);
                  }
                }
                if (stuckRuns.length === 0) {
                  core.info(`  No action_required runs to re-run`);
                }
              } catch (err) {
                core.warning(`  Failed listing runs: ${err.message}`);
              }

              // â”€â”€â”€ STEP 5: Add labels â”€â”€â”€
              try {
                const toAdd = [];
                if (!labels.includes('agent-task')) toAdd.push('agent-task');
                if (!labels.includes('agent-automerge')) toAdd.push('agent-automerge');
                if ((runtime.done || runtimeStalled) && !labels.includes('agent-work-done')) {
                  toAdd.push('agent-work-done');
                }
                if (runtimeStalled && !labels.includes('agent-runtime-timeout')) {
                  toAdd.push('agent-runtime-timeout');
                }
                if (toAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: pr.number,
                    labels: toAdd,
                  });
                  core.info(`  Added labels: ${toAdd.join(', ')}`);
                }
              } catch (err) {
                core.warning(`  Label error: ${err.message}`);
              }

              // â”€â”€â”€ STEP 6: Approve the PR (create review) â”€â”€â”€
              if (!pr.draft) {
                try {
                  await github.rest.pulls.createReview({
                    owner, repo,
                    pull_number: pr.number,
                    event: 'APPROVE',
                    body: `Auto-approved: PR from ${pr.user.login} agent.`,
                  });
                  core.info(`  âœ“ Approved PR #${pr.number}`);
                } catch (err) {
                  // Already approved or other error â€” not fatal
                  core.warning(`  Could not approve PR: ${err.message}`);
                }
              }

              // â”€â”€â”€ STEP 7: Auto-merge if ready â”€â”€â”€
              // Directly merge here instead of delegating to agent-pr-automation,
              // which gets blocked by action_required for bot accounts.
              if (!pr.draft && prDetail.mergeable === true) {
                const mergeLabels = [...labels];
                // Include labels we just added
                if (!mergeLabels.includes('agent-task')) mergeLabels.push('agent-task');
                if (!mergeLabels.includes('agent-automerge')) mergeLabels.push('agent-automerge');
                if (!mergeLabels.includes('agent-work-done') && (runtime.done || runtimeStalled)) {
                  mergeLabels.push('agent-work-done');
                }

                if (mergeLabels.includes('agent-work-done') && mergeLabels.includes('agent-automerge')) {
                  try {
                    const result = await github.rest.pulls.merge({
                      owner, repo,
                      pull_number: pr.number,
                      merge_method: 'squash',
                      commit_title: pr.title,
                      commit_message: `${prDetail.body || ''}\n\nAuto-merged by unstick workflow.`,
                    });
                    core.info(`  âœ“ Merged PR #${pr.number} (SHA: ${result.data.sha})`);

                    // Close linked issue
                    const issueNumber = extractLinkedIssue(prDetail.body);
                    if (issueNumber) {
                      try {
                        await github.rest.issues.update({
                          owner, repo,
                          issue_number: issueNumber,
                          state: 'closed',
                          state_reason: 'completed',
                        });
                        core.info(`  âœ“ Closed linked issue #${issueNumber}`);
                      } catch (err) {
                        core.warning(`  Could not close issue #${issueNumber}: ${err.message}`);
                      }
                    }
                    needsAssignment = true;
                    needsRoadmapScan = true;
                    continue;
                  } catch (err) {
                    core.warning(`  Merge failed: ${err.message}`);
                    // Not fatal â€” agent-pr-automation may still handle it
                  }
                } else {
                  core.info(`  Not all merge labels present â€” skipping merge`);
                }
              } else if (!pr.draft && prDetail.mergeable === null) {
                core.info(`  Mergeability still pending â€” will retry next run`);
                needsRetry = true;
              }

              core.info(`  âœ“ PR #${pr.number} processed`);
            }

            core.info(`\nDone. Processed ${agentPRs.length} agent PRs.`);

            // â”€â”€â”€ Auto-assign next unassigned issue if a slot freed up â”€â”€â”€
            // On manual dispatch or push-to-main, always try to assign (kickstart)
            const shouldAssign = needsAssignment
              || context.eventName === 'workflow_dispatch'
              || context.eventName === 'push';
            if (shouldAssign) {
              core.info('\n--- Attempting to assign next unassigned agent-task issue ---');
              await assignNextUnassignedIssue();
            }

            // Run roadmap scanner on manual dispatch too (create missing issues)
            if (context.eventName === 'workflow_dispatch') {
              needsRoadmapScan = true;
            }

            core.setOutput('needs_retry', needsRetry ? 'true' : 'false');
            core.setOutput('needs_roadmap_scan', needsRoadmapScan ? 'true' : 'false');
            core.info(`Needs retry: ${needsRetry}, roadmap scan: ${needsRoadmapScan}`);

      - name: Self-dispatch retry if work remains
        if: steps.process.outputs.needs_retry == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            // Wait 3 minutes then re-dispatch to avoid relying on unreliable cron
            const delayMs = 3 * 60 * 1000;
            core.info(`Waiting ${delayMs/1000}s before self-dispatch...`);
            await new Promise(r => setTimeout(r, delayMs));
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'unstick-draft-prs.yml',
              ref: 'main',
            });
            core.info('Self-dispatched unstick workflow for retry');

      - name: Run roadmap scanner (create issues from project-brief)
        if: steps.process.outputs.needs_roadmap_scan == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AGENT_PAT: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          DRY_RUN: 'false'
        run: node .github/scripts/orchestrator.js
