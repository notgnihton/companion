name: Unstick Agent Draft PRs

# Runs every 5 minutes to catch agent draft PRs and process them.
# Handles PRs from Claude (Anthropic), Codex (OpenAI), and Copilot (GitHub).
# Also available as manual dispatch.
on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  unstick:
    runs-on: ubuntu-latest
    env:
      AGENT_PAT: ${{ secrets.AGENT_PAT }}
    steps:
      - name: Process all agent draft PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // All known AI coding agent bot logins
            const AGENT_BOTS = new Set([
              'Copilot',
              'copilot-swe-agent[bot]',
              'app/copilot-swe-agent',
              'Claude',
              'anthropic-code-agent[bot]',
              'app/anthropic-code-agent',
              'Codex',
              'openai-code-agent[bot]',
              'app/openai-code-agent',
              'chatgpt-codex-connector[bot]'
            ]);

            // Map display names to their [bot] usernames for reassignment
            const AGENT_REASSIGN = [
              { botUser: 'anthropic-code-agent[bot]', name: 'Claude' },
              { botUser: 'openai-code-agent[bot]',    name: 'Codex' },
              { botUser: 'chatgpt-codex-connector[bot]', name: 'Codex-Connector' },
              { botUser: 'copilot-swe-agent[bot]',    name: 'Copilot' },
            ];

            // Minimum age (minutes) before we consider closing a conflicting PR
            const MIN_AGE_MINUTES = 30;
            // Minimum time since last update before we assume agent is stale
            const MIN_STALE_MINUTES = 15;
            // After this many stale minutes with no active runtime, force-progress draft PRs
            const MIN_RUNTIME_STALL_MINUTES = 15;

            // Map PR author to their expected runtime workflow name
            const RUNTIME_WORKFLOWS = {
              'Claude': 'Running Claude',
              'anthropic-code-agent[bot]': 'Running Claude',
              'app/anthropic-code-agent': 'Running Claude',
              'Codex': 'Running OpenAI Codex',
              'openai-code-agent[bot]': 'Running OpenAI Codex',
              'app/openai-code-agent': 'Running OpenAI Codex',
              'chatgpt-codex-connector[bot]': 'Running OpenAI Codex',
              'Copilot': 'Running Copilot coding agent',
              'copilot-swe-agent[bot]': 'Running Copilot coding agent',
              'app/copilot-swe-agent': 'Running Copilot coding agent',
            };

            // Check if an agent's runtime workflow has completed or is still active for this PR
            async function getAgentRuntimeState(prAuthor, prNumber, headSha) {
              const workflowName = RUNTIME_WORKFLOWS[prAuthor];
              if (!workflowName) {
                return { done: false, active: false, seen: false };
              }
              try {
                const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  head_sha: headSha,
                  per_page: 10,
                });
                // Also check runs not filtered by SHA (agent runtimes may not set head_sha)
                const { data: recentRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  per_page: 50,
                });
                const allRuns = [...runs.workflow_runs, ...recentRuns.workflow_runs];
                const runtimeRuns = allRuns.filter((run) => {
                  if (run.name !== workflowName) {
                    return false;
                  }
                  if (run.head_sha === headSha) {
                    return true;
                  }
                  if (Array.isArray(run.pull_requests)) {
                    return run.pull_requests.some((linkedPr) => linkedPr.number === prNumber);
                  }
                  return false;
                });

                return {
                  done: runtimeRuns.some((run) => run.status === 'completed'),
                  active: runtimeRuns.some((run) => run.status !== 'completed'),
                  seen: runtimeRuns.length > 0
                };
              } catch {
                return { done: false, active: false, seen: false };
              }
            }

            // List all open PRs
            const { data: prs } = await github.rest.pulls.list({
              owner, repo,
              state: 'open',
              per_page: 100,
            });

            const agentPRs = prs.filter(pr => AGENT_BOTS.has(pr.user.login));

            core.info(`Found ${agentPRs.length} open agent PRs`);

            for (const pr of agentPRs) {
              core.info(`\n--- PR #${pr.number}: ${pr.title} (by ${pr.user.login}, draft: ${pr.draft}) ---`);

              const now = Date.now();
              const createdAt = new Date(pr.created_at).getTime();
              const updatedAt = new Date(pr.updated_at).getTime();
              const ageMinutes = Math.round((now - createdAt) / 60000);
              const staleMins = Math.round((now - updatedAt) / 60000);
              core.info(`  Age: ${ageMinutes}m, last updated: ${staleMins}m ago`);

              // Check if the agent's runtime has finished
              const runtime = await getAgentRuntimeState(pr.user.login, pr.number, pr.head.sha);
              core.info(
                `  Agent runtime state: done=${runtime.done}, active=${runtime.active}, seen=${runtime.seen}`
              );

              // For draft PRs, skip very recent updates while work is likely still in progress.
              if (pr.draft && staleMins < MIN_STALE_MINUTES && !runtime.done) {
                core.info(`  Skipping draft: updated ${staleMins}m ago (< ${MIN_STALE_MINUTES}m) and still in progress`);
                continue;
              }

              // Check if there are actual file changes
              const { data: files } = await github.rest.pulls.listFiles({
                owner, repo,
                pull_number: pr.number,
              });

              if (files.length === 0) {
                core.info(`  Skipping: 0 files changed — agent is still working`);
                continue;
              }

              core.info(`  ${files.length} file(s) changed — processing`);

              let labels = pr.labels.map(l => l.name);

              // If the agent pushed a new head, clear stale completion marker.
              // This prevents auto-merge of work that is no longer current.
              if (pr.draft && !runtime.done && labels.includes('agent-work-done')) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: 'agent-work-done',
                  });
                  labels = labels.filter((name) => name !== 'agent-work-done');
                  core.info(`  Removed stale label: agent-work-done`);
                } catch (err) {
                  core.warning(`  Could not remove stale agent-work-done label: ${err.message}`);
                }
              }

              // Step 4: Check for merge conflicts — only close if old + stale
              const { data: prDetail } = await github.rest.pulls.get({
                owner, repo,
                pull_number: pr.number,
              });

              if (prDetail.mergeable === false) {
                // Don't close young PRs — give agents time to finish and update
                if (ageMinutes < MIN_AGE_MINUTES) {
                  core.info(`  PR has conflicts but is only ${ageMinutes}m old (< ${MIN_AGE_MINUTES}m) — skipping, will retry later`);
                  continue;
                }

                // Try to rebase/update the branch first before giving up
                try {
                  await github.rest.pulls.updateBranch({
                    owner, repo,
                    pull_number: pr.number,
                  });
                  core.info(`  Updated PR branch with latest main — will check mergeability next run`);
                  continue;
                } catch (err) {
                  core.info(`  Could not auto-update branch: ${err.message}`);
                }

                core.warning(`  PR #${pr.number} has unresolvable merge conflicts (age: ${ageMinutes}m) — closing`);
                await github.rest.pulls.update({
                  owner, repo,
                  pull_number: pr.number,
                  state: 'closed',
                });

                // Find and reassign the linked issue to trigger a fresh attempt
                const bodyMatch = pr.body && pr.body.match(/(?:Fixes|Closes|Resolves)\s+#(\d+)/i);
                if (bodyMatch) {
                  const issueNumber = parseInt(bodyMatch[1]);
                  core.info(`  Reassigning linked issue #${issueNumber}`);
                  try {
                    // Remove existing assignees first
                    const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                    const currentAssignees = issue.assignees.map(a => a.login);
                    if (currentAssignees.length > 0) {
                      await github.rest.issues.removeAssignees({
                        owner, repo,
                        issue_number: issueNumber,
                        assignees: currentAssignees,
                      });
                    }

                    // Wait for unassign event to register
                    await new Promise(r => setTimeout(r, 2000));

                    // Re-assign via agent API — try Claude, then Codex, then Copilot
                    const token = process.env.AGENT_PAT || process.env.GITHUB_TOKEN;
                    let reassigned = false;
                    for (const provider of AGENT_REASSIGN) {
                      try {
                        const body = { assignees: [provider.botUser] };
                        if (provider.name === 'Copilot') {
                          body.agent_assignment = {
                            target_repo: `${owner}/${repo}`,
                            base_branch: 'main',
                          };
                        }
                        const response = await fetch(
                          `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`,
                          {
                            method: 'POST',
                            headers: {
                              'Authorization': `token ${token}`,
                              'Accept': 'application/vnd.github+json',
                              'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(body),
                          }
                        );
                        if (response.ok) {
                          const data = await response.json();
                          const logins = (data.assignees || []).map(a => a.login);
                          if (logins.includes(provider.name)) {
                            core.info(`  Reassigned to ${provider.name}`);
                            reassigned = true;
                            await github.rest.issues.createComment({
                              owner, repo,
                              issue_number: issueNumber,
                              body: `PR #${pr.number} was closed due to merge conflicts. Reassigning to ${provider.name} for a fresh attempt.`,
                            });
                            break;
                          }
                        }
                      } catch (err) {
                        core.warning(`  ${provider.name} reassignment failed: ${err.message}`);
                      }
                    }
                    if (!reassigned) {
                      core.warning(`  Could not reassign issue #${issueNumber} to any agent`);
                    }
                  } catch (err) {
                    core.warning(`  Could not reassign issue: ${err.message}`);
                  }
                } else {
                  core.info(`  No linked issue found in PR body`);
                }
                continue;
              }

              // mergeable can be null (not yet computed) — skip and retry next run
              if (prDetail.mergeable === null) {
                core.info(`  Mergeability not yet computed — continuing with draft progression checks`);
              }

              const runtimeStalled =
                labels.includes('agent-runtime-timeout') ||
                (!runtime.done && !runtime.active && staleMins >= MIN_RUNTIME_STALL_MINUTES);

              // Hard gate: move drafts only when runtime is complete, or when runtime appears stalled.
              if (!runtime.done && !runtimeStalled) {
                core.info(
                  `  Runtime not completed yet (stale ${staleMins}m < ${MIN_RUNTIME_STALL_MINUTES}m stall threshold) — keeping draft in progress`
                );
                continue;
              }
              if (runtimeStalled) {
                core.warning(
                  `  Runtime appears stalled for ${staleMins}m with no active run — force progressing draft to review`
                );
              }

              // Step 1: Mark ready for review if draft
              if (pr.draft) {
                try {
                  const mutation = `mutation($id: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $id }) {
                      pullRequest { id number isDraft }
                    }
                  }`;
                  await github.graphql(mutation, { id: pr.node_id });
                  core.info(`  Marked PR #${pr.number} as ready for review`);
                } catch (err) {
                  core.warning(`  Could not mark ready: ${err.message}`);
                  continue;
                }
              }

              // Step 2: Approve workflow runs
              try {
                const runs = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  head_sha: pr.head.sha,
                  status: 'action_required',
                });
                for (const run of runs.data.workflow_runs) {
                  try {
                    await github.rest.actions.approveWorkflowRun({ owner, repo, run_id: run.id });
                    core.info(`  Approved workflow run ${run.id}`);
                  } catch (err) {
                    core.warning(`  Could not approve run ${run.id}: ${err.message}`);
                  }
                }
              } catch (err) {
                core.warning(`  Failed listing runs: ${err.message}`);
              }

              // Step 3: Add labels
              try {
                const toAdd = [];
                if (!labels.includes('agent-task')) toAdd.push('agent-task');
                if (!labels.includes('agent-automerge')) toAdd.push('agent-automerge');
                if ((runtime.done || runtimeStalled) && !labels.includes('agent-work-done')) {
                  toAdd.push('agent-work-done');
                }
                if (runtimeStalled && !labels.includes('agent-runtime-timeout')) toAdd.push('agent-runtime-timeout');
                if (toAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: pr.number,
                    labels: toAdd,
                  });
                  core.info(`  Added labels: ${toAdd.join(', ')}`);
                }
              } catch (err) {
                core.warning(`  Label error: ${err.message}`);
              }

              core.info(`  PR is ready; merge is delegated to agent-pr-automation.yml`);
            }

            core.info(`\nDone. Processed ${agentPRs.length} agent PRs.`);
