name: Unstick Agent Draft PRs

# Processes agent draft PRs: detect done → rebase/resolve conflicts → mark ready → merge.
# Triggers:
#   - Cron every 3 min (GitHub may delay; not guaranteed)
#   - On push to main (catches post-merge immediately)
#   - Manual dispatch
on:
  schedule:
    - cron: '*/3 * * * *'
  push:
    branches: [main]
  workflow_dispatch:

# Serialize merge operations to prevent cascading stale-branch conflicts
concurrency:
  group: agent-merge-queue
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  unstick:
    runs-on: ubuntu-latest
    env:
      PAT_COLLAB_TWO: ${{ secrets.PAT_COLLAB_TWO }}
      AGENT_PAT: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT }}
      AGENT_PAT_COLLAB: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB }}
    steps:
      - name: Checkout repo (needed for rebase operations)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}

      - name: Process all agent draft PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_COLLAB_TWO || secrets.AGENT_PAT_COLLAB || secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // All known AI coding agent bot logins
            const AGENT_BOTS = new Set([
              'Copilot',
              'copilot-swe-agent[bot]',
              'app/copilot-swe-agent',
              'Claude',
              'anthropic-code-agent[bot]',
              'app/anthropic-code-agent',
              'Codex',
              'openai-code-agent[bot]',
              'app/openai-code-agent',
              'chatgpt-codex-connector[bot]'
            ]);

            // Map display names to their [bot] usernames for reassignment
            const AGENT_REASSIGN = [
              { botUser: 'copilot-swe-agent[bot]',    name: 'Copilot' },
              { botUser: 'anthropic-code-agent[bot]',  name: 'Claude' },
              { botUser: 'openai-code-agent[bot]',     name: 'Codex' },
              { botUser: 'chatgpt-codex-connector[bot]', name: 'Codex-Connector' },
            ];

            // Timing thresholds
            const MIN_AGE_MINUTES = 30;
            const MIN_STALE_MINUTES = 15;
            const MIN_RUNTIME_STALL_MINUTES = 15;

            // Map PR author to their expected runtime workflow name
            const RUNTIME_WORKFLOWS = {
              'Claude': 'Running Claude',
              'anthropic-code-agent[bot]': 'Running Claude',
              'app/anthropic-code-agent': 'Running Claude',
              'Codex': 'Running OpenAI Codex',
              'openai-code-agent[bot]': 'Running OpenAI Codex',
              'app/openai-code-agent': 'Running OpenAI Codex',
              'chatgpt-codex-connector[bot]': 'Running OpenAI Codex',
              'Copilot': 'Running Copilot coding agent',
              'copilot-swe-agent[bot]': 'Running Copilot coding agent',
              'app/copilot-swe-agent': 'Running Copilot coding agent',
            };

            // Check if an agent's runtime workflow has completed or is still active
            async function getAgentRuntimeState(prAuthor, prNumber, headSha) {
              const workflowName = RUNTIME_WORKFLOWS[prAuthor];
              if (!workflowName) {
                return { done: false, active: false, seen: false };
              }
              try {
                const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  head_sha: headSha,
                  per_page: 10,
                });
                const { data: recentRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  per_page: 50,
                });
                const allRuns = [...runs.workflow_runs, ...recentRuns.workflow_runs];
                const runtimeRuns = allRuns.filter((run) => {
                  if (run.name !== workflowName) return false;
                  if (run.head_sha === headSha) return true;
                  if (Array.isArray(run.pull_requests)) {
                    return run.pull_requests.some((linkedPr) => linkedPr.number === prNumber);
                  }
                  return false;
                });
                return {
                  done: runtimeRuns.some((run) => run.status === 'completed'),
                  active: runtimeRuns.some((run) => run.status !== 'completed'),
                  seen: runtimeRuns.length > 0
                };
              } catch {
                return { done: false, active: false, seen: false };
              }
            }

            // Try to rebase a branch onto main using git (clean rebase only)
            function tryRebase(branchName) {
              try {
                execSync('git config user.name "github-actions[bot]"', { stdio: 'pipe' });
                execSync('git config user.email "github-actions[bot]@users.noreply.github.com"', { stdio: 'pipe' });
                execSync('git fetch origin main', { stdio: 'pipe' });
                execSync(`git fetch origin ${branchName}`, { stdio: 'pipe' });
                execSync(`git checkout ${branchName}`, { stdio: 'pipe' });
                execSync('git reset --hard', { stdio: 'pipe' });

                // Check if rebase is needed
                const behindCount = execSync('git rev-list --count HEAD..origin/main', { encoding: 'utf8' }).trim();
                if (behindCount === '0') {
                  return { success: true, needed: false };
                }

                // Attempt clean rebase only — never silently overwrite agent work
                try {
                  execSync('git rebase origin/main', { stdio: 'pipe' });
                  execSync(`git push --force-with-lease origin ${branchName}`, { stdio: 'pipe' });
                  return { success: true, needed: true };
                } catch {
                  // Clean rebase failed — conflicts exist, don't try to auto-resolve
                  // Agent work should not be silently overwritten with main's version
                  try { execSync('git rebase --abort', { stdio: 'pipe' }); } catch {}
                  return { success: false, needed: true };
                }
              } catch (err) {
                try { execSync('git rebase --abort', { stdio: 'pipe' }); } catch {}
                return { success: false, needed: true, error: err.message };
              }
            }

            // Extract linked issue number from PR body
            function extractLinkedIssue(body) {
              const match = body && body.match(/(?:Fixes|Closes|Resolves)\s+#(\d+)/i);
              return match ? parseInt(match[1]) : null;
            }

            // Assign an agent to fix merge conflicts on a PR
            async function assignAgentToFixConflicts(pr, issueNumber) {
              const token = process.env.PAT_COLLAB_TWO || process.env.AGENT_PAT_COLLAB || process.env.AGENT_PAT || process.env.GITHUB_TOKEN;

              await github.rest.issues.createComment({
                owner, repo,
                issue_number: pr.number,
                body: [
                  '⚠️ **Merge conflicts detected** that could not be automatically resolved.',
                  '',
                  'Closing this PR and reassigning the linked issue to an agent for a fresh attempt.',
                ].join('\n'),
              });

              if (issueNumber) {
                core.info(`  Closing conflicting PR and reassigning issue #${issueNumber}`);

                await github.rest.pulls.update({
                  owner, repo,
                  pull_number: pr.number,
                  state: 'closed',
                });

                // Remove existing assignees
                try {
                  const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                  const currentAssignees = issue.assignees.map(a => a.login);
                  if (currentAssignees.length > 0) {
                    await github.rest.issues.removeAssignees({
                      owner, repo,
                      issue_number: issueNumber,
                      assignees: currentAssignees,
                    });
                  }
                } catch (err) {
                  core.warning(`  Could not remove assignees: ${err.message}`);
                }

                await new Promise(r => setTimeout(r, 2000));

                // Try each agent in priority order
                let reassigned = false;
                for (const provider of AGENT_REASSIGN) {
                  try {
                    const body = { assignees: [provider.botUser] };
                    if (provider.name === 'Copilot') {
                      body.agent_assignment = {
                        target_repo: `${owner}/${repo}`,
                        base_branch: 'main',
                      };
                    }
                    const response = await fetch(
                      `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`,
                      {
                        method: 'POST',
                        headers: {
                          'Authorization': `token ${token}`,
                          'Accept': 'application/vnd.github+json',
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(body),
                      }
                    );
                    if (response.ok) {
                      const data = await response.json();
                      const logins = (data.assignees || []).map(a => a.login);
                      if (logins.includes(provider.name) || logins.includes(provider.botUser)) {
                        core.info(`  Reassigned issue #${issueNumber} to ${provider.name}`);
                        reassigned = true;
                        await github.rest.issues.createComment({
                          owner, repo,
                          issue_number: issueNumber,
                          body: `PR #${pr.number} closed due to unresolvable conflicts. Reassigned to **${provider.name}** for a fresh attempt.`,
                        });
                        break;
                      }
                    }
                  } catch (err) {
                    core.warning(`  ${provider.name} reassignment failed: ${err.message}`);
                  }
                }
                if (!reassigned) {
                  core.warning(`  Could not reassign issue #${issueNumber} — reopening PR`);
                  await github.rest.pulls.update({
                    owner, repo,
                    pull_number: pr.number,
                    state: 'open',
                  });
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: pr.number,
                    labels: ['needs-conflict-resolution'],
                  });
                }
              } else {
                core.info(`  No linked issue — labeling for manual attention`);
                await github.rest.issues.addLabels({
                  owner, repo,
                  issue_number: pr.number,
                  labels: ['needs-conflict-resolution'],
                });
              }
            }

            // ─── Main logic ───

            const { data: prs } = await github.rest.pulls.list({
              owner, repo,
              state: 'open',
              per_page: 100,
            });

            const agentPRs = prs.filter(pr => AGENT_BOTS.has(pr.user.login));
            core.info(`Found ${agentPRs.length} open agent PRs`);

            for (const pr of agentPRs) {
              core.info(`\n--- PR #${pr.number}: ${pr.title} (by ${pr.user.login}, draft: ${pr.draft}) ---`);

              const now = Date.now();
              const createdAt = new Date(pr.created_at).getTime();
              const updatedAt = new Date(pr.updated_at).getTime();
              const ageMinutes = Math.round((now - createdAt) / 60000);
              const staleMins = Math.round((now - updatedAt) / 60000);
              core.info(`  Age: ${ageMinutes}m, last updated: ${staleMins}m ago`);

              // Check runtime state
              const runtime = await getAgentRuntimeState(pr.user.login, pr.number, pr.head.sha);
              core.info(`  Runtime: done=${runtime.done}, active=${runtime.active}, seen=${runtime.seen}`);

              // Skip very recently updated drafts while agent is likely still working
              if (pr.draft && staleMins < MIN_STALE_MINUTES && !runtime.done) {
                core.info(`  Skipping: updated ${staleMins}m ago and runtime not done`);
                continue;
              }

              // Check file changes
              const { data: files } = await github.rest.pulls.listFiles({
                owner, repo,
                pull_number: pr.number,
              });

              if (files.length === 0) {
                core.info(`  Skipping: 0 files changed`);
                continue;
              }
              core.info(`  ${files.length} file(s) changed`);

              let labels = pr.labels.map(l => l.name);

              // Clear stale agent-work-done if agent pushed new work on a draft
              if (pr.draft && !runtime.done && labels.includes('agent-work-done')) {
                try {
                  await github.rest.issues.removeLabel({
                    owner, repo,
                    issue_number: pr.number,
                    name: 'agent-work-done',
                  });
                  labels = labels.filter(n => n !== 'agent-work-done');
                  core.info(`  Removed stale agent-work-done label`);
                } catch (err) {
                  core.warning(`  Could not remove stale label: ${err.message}`);
                }
              }

              // If PR already has agent-work-done label (from a previous run) and is not draft,
              // treat it as effectively done — the runtime check is no longer relevant
              // (e.g., head SHA changed after rebase so runtime runs can't be found).
              const alreadyMarkedDone = !pr.draft && labels.includes('agent-work-done');

              // Determine if runtime is stalled
              const runtimeStalled =
                labels.includes('agent-runtime-timeout') ||
                (!runtime.done && !runtime.active && staleMins >= MIN_RUNTIME_STALL_MINUTES);

              // Only proceed if runtime is done, stalled, or already marked done
              if (!runtime.done && !runtimeStalled && !alreadyMarkedDone) {
                core.info(`  Runtime not done, not stalled — skipping`);
                continue;
              }

              if (runtimeStalled) {
                core.warning(`  Runtime stalled for ${staleMins}m — force progressing`);
              }

              // ─── STEP 1: Rebase onto main BEFORE marking ready ───
              core.info(`  Attempting rebase onto main...`);
              const rebaseResult = tryRebase(pr.head.ref);

              if (rebaseResult.needed && rebaseResult.success) {
                core.info(`  ✓ Rebase successful`);
                // Remove needs-rebase label if it was set by agent-pr-automation
                try {
                  await github.rest.issues.removeLabel({
                    owner, repo,
                    issue_number: pr.number,
                    name: 'needs-rebase',
                  });
                } catch {} // Label may not exist — ignore
                // Wait for GitHub to process the push
                await new Promise(r => setTimeout(r, 3000));
              } else if (rebaseResult.needed && !rebaseResult.success) {
                core.warning(`  ✗ Rebase failed — unresolvable merge conflicts`);

                // Give young PRs time before escalating
                if (ageMinutes < MIN_AGE_MINUTES) {
                  core.info(`  PR only ${ageMinutes}m old — will retry next run`);
                  continue;
                }

                // Assign an agent to fix the conflicts
                const issueNumber = extractLinkedIssue(pr.body);
                await assignAgentToFixConflicts(pr, issueNumber);
                continue;
              } else {
                core.info(`  Already up to date with main`);
              }

              // ─── STEP 2: Verify mergeability after rebase ───
              const { data: prDetail } = await github.rest.pulls.get({
                owner, repo,
                pull_number: pr.number,
              });

              if (prDetail.mergeable === false) {
                core.warning(`  Still has conflicts after rebase — will retry next run`);
                continue;
              }

              // ─── STEP 3: Mark ready for review (only if no conflicts) ───
              if (pr.draft && prDetail.mergeable !== false) {
                try {
                  const mutation = `mutation($id: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $id }) {
                      pullRequest { id number isDraft }
                    }
                  }`;
                  await github.graphql(mutation, { id: pr.node_id });
                  core.info(`  ✓ Marked PR #${pr.number} as ready for review`);
                } catch (err) {
                  core.warning(`  Could not mark ready: ${err.message}`);
                  continue;
                }
              }

              // ─── STEP 4: Re-run action_required workflow runs ───
              // GitHub blocks pull_request_target workflows for bot accounts
              // with "action_required". We can't approve them (403 for non-fork PRs),
              // but re-running them works.
              try {
                const { data: allRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  head_sha: prDetail.head.sha,
                  per_page: 30,
                });
                const stuckRuns = allRuns.workflow_runs.filter(r => r.conclusion === 'action_required');
                for (const run of stuckRuns) {
                  try {
                    await github.rest.actions.reRunWorkflow({ owner, repo, run_id: run.id });
                    core.info(`  Re-ran stuck workflow run ${run.id} (${run.name})`);
                  } catch (err) {
                    core.warning(`  Could not re-run ${run.id}: ${err.message}`);
                  }
                }
                if (stuckRuns.length === 0) {
                  core.info(`  No action_required runs to re-run`);
                }
              } catch (err) {
                core.warning(`  Failed listing runs: ${err.message}`);
              }

              // ─── STEP 5: Add labels ───
              try {
                const toAdd = [];
                if (!labels.includes('agent-task')) toAdd.push('agent-task');
                if (!labels.includes('agent-automerge')) toAdd.push('agent-automerge');
                if ((runtime.done || runtimeStalled) && !labels.includes('agent-work-done')) {
                  toAdd.push('agent-work-done');
                }
                if (runtimeStalled && !labels.includes('agent-runtime-timeout')) {
                  toAdd.push('agent-runtime-timeout');
                }
                if (toAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: pr.number,
                    labels: toAdd,
                  });
                  core.info(`  Added labels: ${toAdd.join(', ')}`);
                }
              } catch (err) {
                core.warning(`  Label error: ${err.message}`);
              }

              // ─── STEP 6: Approve the PR (create review) ───
              if (!pr.draft) {
                try {
                  await github.rest.pulls.createReview({
                    owner, repo,
                    pull_number: pr.number,
                    event: 'APPROVE',
                    body: `Auto-approved: PR from ${pr.user.login} agent.`,
                  });
                  core.info(`  ✓ Approved PR #${pr.number}`);
                } catch (err) {
                  // Already approved or other error — not fatal
                  core.warning(`  Could not approve PR: ${err.message}`);
                }
              }

              // ─── STEP 7: Auto-merge if ready ───
              // Directly merge here instead of delegating to agent-pr-automation,
              // which gets blocked by action_required for bot accounts.
              if (!pr.draft && prDetail.mergeable === true) {
                const mergeLabels = [...labels];
                // Include labels we just added
                if (!mergeLabels.includes('agent-task')) mergeLabels.push('agent-task');
                if (!mergeLabels.includes('agent-automerge')) mergeLabels.push('agent-automerge');
                if (!mergeLabels.includes('agent-work-done') && (runtime.done || runtimeStalled)) {
                  mergeLabels.push('agent-work-done');
                }

                if (mergeLabels.includes('agent-work-done') && mergeLabels.includes('agent-automerge')) {
                  try {
                    const result = await github.rest.pulls.merge({
                      owner, repo,
                      pull_number: pr.number,
                      merge_method: 'squash',
                      commit_title: pr.title,
                      commit_message: `${prDetail.body || ''}\n\nAuto-merged by unstick workflow.`,
                    });
                    core.info(`  ✓ Merged PR #${pr.number} (SHA: ${result.data.sha})`);

                    // Close linked issue
                    const issueNumber = extractLinkedIssue(prDetail.body);
                    if (issueNumber) {
                      try {
                        await github.rest.issues.update({
                          owner, repo,
                          issue_number: issueNumber,
                          state: 'closed',
                          state_reason: 'completed',
                        });
                        core.info(`  ✓ Closed linked issue #${issueNumber}`);
                      } catch (err) {
                        core.warning(`  Could not close issue #${issueNumber}: ${err.message}`);
                      }
                    }
                    continue;
                  } catch (err) {
                    core.warning(`  Merge failed: ${err.message}`);
                    // Not fatal — agent-pr-automation may still handle it
                  }
                } else {
                  core.info(`  Not all merge labels present — skipping merge`);
                }
              } else if (!pr.draft && prDetail.mergeable === null) {
                core.info(`  Mergeability still pending — will retry next run`);
              }

              core.info(`  ✓ PR #${pr.number} processed`);
            }

            core.info(`\nDone. Processed ${agentPRs.length} agent PRs.`);
